/**
 * Device Management Service - í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
 * v3.1 ì•„í‚¤í…ì²˜ 100% ì¤€ìˆ˜: Storage API ê¸°ë°˜ + ì§ì ‘ ì—°ë™ ì„œë¹„ìŠ¤ë“¤
 * ê³„ì•½(device-service.yaml) 100% êµ¬í˜„
 */

import { 
  Device, 
  DeviceListResponse,
  DeviceCreateRequest,
  DeviceUpdateRequest,
  DeviceFilter,
  DeviceStatusResponse,
  HeartbeatRequest,
  DeviceHealthSummary,
  DeviceMetrics,
  StorageDeviceFilter,
  StorageDeviceCreateRequest
} from '../types';
import { StorageClientService } from './storage-client.service';
import { CacheService } from './cache.service';
import { MetricsService } from './metrics.service';
import { EventBusService } from './event-bus.service';
import { Logger } from '../utils/logger';

export class DeviceManagementService {
  private logger: Logger;

  constructor(
    private storageClient: StorageClientService,    // Storage API ì‚¬ìš©
    private cacheService: CacheService,             // Redis ì§ì ‘
    private metricsService: MetricsService,         // InfluxDB ì§ì ‘
    private eventBusService: EventBusService        // Kafka ì§ì ‘
  ) {
    this.logger = new Logger('DeviceManagementService');
  }

  /**
   * ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('ğŸš€ Initializing Device Management Service...');

      // Storage Service ì—°ê²° í™•ì¸ (ì´ë¯¸ ì•±ì—ì„œ í™•ì¸ë¨)
      const storageHealthy = await this.storageClient.healthCheck();
      if (!storageHealthy) {
        throw new Error('Storage Service is not available');
      }

      // ìºì‹œ, ë©”íŠ¸ë¦­, ì´ë²¤íŠ¸ ì„œë¹„ìŠ¤ëŠ” ì´ë¯¸ ì•± ë ˆë²¨ì—ì„œ ì´ˆê¸°í™”ë¨
      // ì¤‘ë³µ ì—°ê²° ì‹œë„í•˜ì§€ ì•ŠìŒ

      this.logger.logSuccess('Device Management Service initialized successfully');
    } catch (error) {
      this.logger.logError('Failed to initialize Device Management Service', error);
      throw error;
    }
  }

  /**
   * ì„œë¹„ìŠ¤ ì¢…ë£Œ
   */
  async shutdown(): Promise<void> {
    try {
      await this.eventBusService.disconnect();
      await this.metricsService.shutdown();
      await this.cacheService.disconnect();
      this.logger.info('Device Management Service shut down successfully');
    } catch (error) {
      this.logger.error('Error shutting down Device Management Service', error);
    }
  }

  // ============ Device CRUD Operations (Storage API ì‚¬ìš©) ============

  /**
   * ì¥ë¹„ ëª©ë¡ ì¡°íšŒ (ê³„ì•½ ì¤€ìˆ˜: GET /api/v1/devices)
   */
  async getDevices(filters: DeviceFilter): Promise<DeviceListResponse> {
    try {
      // ìºì‹œ í™•ì¸
      const cached = await this.cacheService.getCachedDeviceList(filters);
      if (cached) {
        this.logger.debug('Device list cache hit', { filters });
        return cached;
      }

      // Storage API í˜¸ì¶œ (ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)
      const storageFilters: StorageDeviceFilter = {
        groupId: filters.groupId,
        status: filters.status,
        type: filters.type,
        limit: filters.limit || 20,
        offset: filters.offset || 0
      };

      const result = await this.storageClient.getDevices(storageFilters);

      // ì‹¤ì‹œê°„ ìƒíƒœ ë³´ê°• (Redisì—ì„œ)
      const enrichedDevices = await this.enrichDevicesWithStatus(result.items);
      
      const response: DeviceListResponse = {
        items: enrichedDevices,
        total: result.total,
        limit: result.limit,
        offset: result.offset
      };

      // ìºì‹œ ì €ì¥ (5ë¶„ TTL)
      await this.cacheService.cacheDeviceList(filters, response, 300);

      this.logger.info('Devices retrieved successfully', {
        count: response.items.length,
        total: response.total,
        filters
      });

      return response;
    } catch (error) {
      this.logger.error('Failed to get devices', error, { filters });
      throw error;
    }
  }

  /**
   * ì¥ë¹„ ë“±ë¡ (ê³„ì•½ ì¤€ìˆ˜: POST /api/v1/devices)
   */
  async createDevice(deviceData: DeviceCreateRequest): Promise<Device> {
    try {
      // Storage API í˜¸ì¶œ (ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)
      const storageData: StorageDeviceCreateRequest = {
        name: deviceData.name,
        type: deviceData.type,
        groupId: deviceData.groupId,
        metadata: deviceData.metadata || {},
        tags: deviceData.tags || [],
        status: 'inactive', // ê¸°ë³¸ ìƒíƒœ
        connectionInfo: deviceData.connectionInfo
      };

      const device = await this.storageClient.createDevice(storageData);

      // ì´ë²¤íŠ¸ ë°œí–‰ (Kafka ì§ì ‘)
      await this.eventBusService.publishDeviceCreated(device.id, device);

      // ìºì‹œ ë¬´íš¨í™”
      await this.cacheService.invalidateDeviceCache();

      this.logger.logSuccess('Device created successfully', {
        deviceId: device.id,
        deviceName: device.name,
        deviceType: device.type
      });

      return device;
    } catch (error) {
      this.logger.error('Failed to create device', error, { deviceData });
      throw error;
    }
  }

  /**
   * í•˜íŠ¸ë¹„íŠ¸ ì²˜ë¦¬ (ê³„ì•½ ì¤€ìˆ˜: POST /api/v1/devices/{id}/status)
   */
  async processHeartbeat(id: string, heartbeat: HeartbeatRequest): Promise<void> {
    try {
      // ì¥ë¹„ ì¡´ì¬ í™•ì¸ (Storage API)
      const device = await this.storageClient.getDeviceById(id);

      // ì‹¤ì‹œê°„ ìƒíƒœ ì—…ë°ì´íŠ¸ (Redis ì§ì ‘)
      await this.cacheService.setDeviceStatus(id, heartbeat.status, heartbeat.metrics);
      await this.cacheService.updateHeartbeat(id);

      // ë©”íŠ¸ë¦­ ì €ì¥ (InfluxDB ì§ì ‘)
      if (heartbeat.metrics) {
        await this.metricsService.writeDeviceMetrics(id, heartbeat.metrics);
        
        // ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§
        await this.checkMetricThresholds(id, heartbeat.metrics);
      }

      // ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ë°œí–‰ (í•„ìš”ì‹œ)
      const previousStatus = device.status;
      if (previousStatus !== heartbeat.status) {
        await this.eventBusService.publishDeviceStatusChanged(
          id,
          previousStatus,
          heartbeat.status,
          'Heartbeat status change'
        );
      }

      this.logger.debug('Heartbeat processed successfully', {
        deviceId: id,
        status: heartbeat.status,
        hasMetrics: !!heartbeat.metrics
      });
    } catch (error) {
      this.logger.error('Failed to process heartbeat', error, { deviceId: id, heartbeat });
      throw error;
    }
  }

  /**
   * ë©”íŠ¸ë¦­ ì„ê³„ê°’ í™•ì¸
   */
  private async checkMetricThresholds(deviceId: string, metrics: DeviceMetrics): Promise<void> {
    const thresholds = {
      cpu: 90,
      memory: 85,
      disk: 95
    };

    try {
      // CPU ì„ê³„ê°’ í™•ì¸
      if (metrics.cpu !== undefined && metrics.cpu > thresholds.cpu) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'cpu',
          metrics.cpu,
          thresholds.cpu
        );
      }

      // ë©”ëª¨ë¦¬ ì„ê³„ê°’ í™•ì¸
      if (metrics.memory !== undefined && metrics.memory > thresholds.memory) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'memory',
          metrics.memory,
          thresholds.memory
        );
      }

      // ë””ìŠ¤í¬ ì„ê³„ê°’ í™•ì¸
      if (metrics.disk !== undefined && metrics.disk > thresholds.disk) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'disk',
          metrics.disk,
          thresholds.disk
        );
      }
    } catch (error) {
      this.logger.error('Failed to check metric thresholds', error, { deviceId, metrics });
    }
  }

  /**
   * ì „ì²´ ì¥ë¹„ í—¬ìŠ¤ ìš”ì•½ (ê³„ì•½ ì¤€ìˆ˜: GET /api/v1/devices/health)
   */
  async getDeviceHealthSummary(): Promise<any> {
    try {
      const allDevices = await this.storageClient.getDevices({ limit: 1000, offset: 0 });
      const allStatuses = await this.cacheService.getAllDeviceStatuses();

      let activeDevices = 0;
      let inactiveDevices = 0;
      let errorDevices = 0;
      let maintenanceDevices = 0;

      for (const device of allDevices.items) {
        const status = allStatuses[device.id];
        if (status) {
          switch (status.status) {
            case 'active': activeDevices++; break;
            case 'error': errorDevices++; break;
            case 'maintenance': maintenanceDevices++; break;
            default: inactiveDevices++;
          }
        } else {
          inactiveDevices++;
        }
      }

      return {
        totalDevices: allDevices.total,
        activeDevices,
        inactiveDevices,
        errorDevices,
        maintenanceDevices,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      this.logger.error('Failed to get device health summary', error);
      throw error;
    }
  }

  /**
   * ì¥ë¹„ ëª©ë¡ì— ì‹¤ì‹œê°„ ìƒíƒœ ì •ë³´ ë³´ê°•
   */

  /**
   * ì¥ë¹„ ìƒì„¸ ì¡°íšŒ
   */
  async getDeviceById(id: string): Promise<Device | null> {
    try {
      const device = await this.storageClient.getDeviceById(id);
      
      // ì‹¤ì‹œê°„ ìƒíƒœ ì •ë³´ ë³´ê°•
      const status = await this.cacheService.getDeviceStatus(id);
      
      return {
        ...device,
        status: status?.status || device.status
      };
    } catch (error: any) {
      if (error.message?.includes('not found')) {
        return null;
      }
      throw error;
    }
  }

  /**
   * ì¥ë¹„ ì •ë³´ ìˆ˜ì •
   */
  async updateDevice(id: string, updateData: any): Promise<Device> {
    try {
      // Storage APIë¥¼ í†µí•´ ì—…ë°ì´íŠ¸
      const updatedDevice = await this.storageClient.updateDevice(id, updateData);

      // ìºì‹œ ì •ë³´ë„ ì—…ë°ì´íŠ¸ (ìƒíƒœê°€ ë³€ê²½ëœ ê²½ìš°)
      if (updateData.status) {
        await this.cacheService.setDeviceStatus(id, updateData.status);
      }

      // ì´ë²¤íŠ¸ ë°œí–‰ (ê¸°ì¡´ íŒ¨í„´ ì‚¬ìš©)
      // await this.eventBusService.publishDeviceUpdated(id, updateData); // TODO: Fix event format

      return updatedDevice;
    } catch (error) {
      this.logger.error('Failed to update device', { deviceId: id, error });
      throw error;
    }
  }

  /**
   * ì¥ë¹„ ì‚­ì œ
   */
  async deleteDevice(id: string): Promise<void> {
    try {
      // ê¸°ì¡´ ì¥ë¹„ ì •ë³´ ì¡°íšŒ (ì´ë²¤íŠ¸ ë°œí–‰ìš©)
      const existingDevice = await this.storageClient.getDeviceById(id);

      // Storage APIë¥¼ í†µí•´ ì‚­ì œ
      await this.storageClient.deleteDevice(id);

      // ìºì‹œ ë¬´íš¨í™”
      await this.cacheService.invalidateDeviceCache();
      // ì´ë²¤íŠ¸ ë°œí–‰ (ê¸°ì¡´ íŒ¨í„´ ì‚¬ìš©)
      await this.eventBusService.publishDeviceDeleted(id, existingDevice);

    } catch (error) {
      this.logger.error('Failed to delete device', { deviceId: id, error });
      throw error;
    }
  }

  private async enrichDevicesWithStatus(devices: Device[]): Promise<Device[]> {
    const enrichedDevices: Device[] = [];

    for (const device of devices) {
      const status = await this.cacheService.getDeviceStatus(device.id);
      
      enrichedDevices.push({
        ...device,
        // ì‹¤ì‹œê°„ ìƒíƒœê°€ ìˆìœ¼ë©´ Redis ìƒíƒœ ìš°ì„ , ì—†ìœ¼ë©´ Storage ìƒíƒœ ìœ ì§€
        status: status?.status || device.status
      });
    }

    return enrichedDevices;
  }
}
