/**
 * Device Management Service - 핵심 비즈니스 로직
 * v3.1 아키텍처 100% 준수: Storage API 기반 + 직접 연동 서비스들
 * 계약(device-service.yaml) 100% 구현
 */

import { 
  Device, 
  DeviceListResponse,
  DeviceCreateRequest,
  DeviceUpdateRequest,
  DeviceFilter,
  DeviceStatusResponse,
  HeartbeatRequest,
  DeviceHealthSummary,
  DeviceMetrics,
  StorageDeviceFilter,
  StorageDeviceCreateRequest
} from '../types';
import { StorageClientService } from './storage-client.service';
import { CacheService } from './cache.service';
import { MetricsService } from './metrics.service';
import { EventBusService } from './event-bus.service';
import { Logger } from '../utils/logger';

export class DeviceManagementService {
  private logger: Logger;

  constructor(
    private storageClient: StorageClientService,    // Storage API 사용
    private cacheService: CacheService,             // Redis 직접
    private metricsService: MetricsService,         // InfluxDB 직접
    private eventBusService: EventBusService        // Kafka 직접
  ) {
    this.logger = new Logger('DeviceManagementService');
  }

  /**
   * 서비스 초기화
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('🚀 Initializing Device Management Service...');

      // Storage Service 연결 확인 (이미 앱에서 확인됨)
      const storageHealthy = await this.storageClient.healthCheck();
      if (!storageHealthy) {
        throw new Error('Storage Service is not available');
      }

      // 캐시, 메트릭, 이벤트 서비스는 이미 앱 레벨에서 초기화됨
      // 중복 연결 시도하지 않음

      this.logger.logSuccess('Device Management Service initialized successfully');
    } catch (error) {
      this.logger.logError('Failed to initialize Device Management Service', error);
      throw error;
    }
  }

  /**
   * 서비스 종료
   */
  async shutdown(): Promise<void> {
    try {
      await this.eventBusService.disconnect();
      await this.metricsService.shutdown();
      await this.cacheService.disconnect();
      this.logger.info('Device Management Service shut down successfully');
    } catch (error) {
      this.logger.error('Error shutting down Device Management Service', error);
    }
  }

  // ============ Device CRUD Operations (Storage API 사용) ============

  /**
   * 장비 목록 조회 (계약 준수: GET /api/v1/devices)
   */
  async getDevices(filters: DeviceFilter): Promise<DeviceListResponse> {
    try {
      // 캐시 확인
      const cached = await this.cacheService.getCachedDeviceList(filters);
      if (cached) {
        this.logger.debug('Device list cache hit', { filters });
        return cached;
      }

      // Storage API 호출 (아키텍처 준수)
      const storageFilters: StorageDeviceFilter = {
        groupId: filters.groupId,
        status: filters.status,
        type: filters.type,
        limit: filters.limit || 20,
        offset: filters.offset || 0
      };

      const result = await this.storageClient.getDevices(storageFilters);

      // 실시간 상태 보강 (Redis에서)
      const enrichedDevices = await this.enrichDevicesWithStatus(result.items);
      
      const response: DeviceListResponse = {
        items: enrichedDevices,
        total: result.total,
        limit: result.limit,
        offset: result.offset
      };

      // 캐시 저장 (5분 TTL)
      await this.cacheService.cacheDeviceList(filters, response, 300);

      this.logger.info('Devices retrieved successfully', {
        count: response.items.length,
        total: response.total,
        filters
      });

      return response;
    } catch (error) {
      this.logger.error('Failed to get devices', error, { filters });
      throw error;
    }
  }

  /**
   * 장비 등록 (계약 준수: POST /api/v1/devices)
   */
  async createDevice(deviceData: DeviceCreateRequest): Promise<Device> {
    try {
      // Storage API 호출 (아키텍처 준수)
      const storageData: StorageDeviceCreateRequest = {
        name: deviceData.name,
        type: deviceData.type,
        groupId: deviceData.groupId,
        metadata: deviceData.metadata || {},
        tags: deviceData.tags || [],
        status: 'inactive', // 기본 상태
        connectionInfo: deviceData.connectionInfo
      };

      const device = await this.storageClient.createDevice(storageData);

      // 이벤트 발행 (Kafka 직접)
      await this.eventBusService.publishDeviceCreated(device.id, device);

      // 캐시 무효화
      await this.cacheService.invalidateDeviceCache();

      this.logger.logSuccess('Device created successfully', {
        deviceId: device.id,
        deviceName: device.name,
        deviceType: device.type
      });

      return device;
    } catch (error) {
      this.logger.error('Failed to create device', error, { deviceData });
      throw error;
    }
  }

  /**
   * 하트비트 처리 (계약 준수: POST /api/v1/devices/{id}/status)
   */
  async processHeartbeat(id: string, heartbeat: HeartbeatRequest): Promise<void> {
    try {
      // 장비 존재 확인 (Storage API)
      const device = await this.storageClient.getDeviceById(id);

      // 실시간 상태 업데이트 (Redis 직접)
      await this.cacheService.setDeviceStatus(id, heartbeat.status, heartbeat.metrics);
      await this.cacheService.updateHeartbeat(id);

      // 메트릭 저장 (InfluxDB 직접)
      if (heartbeat.metrics) {
        await this.metricsService.writeDeviceMetrics(id, heartbeat.metrics);
        
        // 임계값 모니터링
        await this.checkMetricThresholds(id, heartbeat.metrics);
      }

      // 상태 변경 이벤트 발행 (필요시)
      const previousStatus = device.status;
      if (previousStatus !== heartbeat.status) {
        await this.eventBusService.publishDeviceStatusChanged(
          id,
          previousStatus,
          heartbeat.status,
          'Heartbeat status change'
        );
      }

      this.logger.debug('Heartbeat processed successfully', {
        deviceId: id,
        status: heartbeat.status,
        hasMetrics: !!heartbeat.metrics
      });
    } catch (error) {
      this.logger.error('Failed to process heartbeat', error, { deviceId: id, heartbeat });
      throw error;
    }
  }

  /**
   * 메트릭 임계값 확인
   */
  private async checkMetricThresholds(deviceId: string, metrics: DeviceMetrics): Promise<void> {
    const thresholds = {
      cpu: 90,
      memory: 85,
      disk: 95
    };

    try {
      // CPU 임계값 확인
      if (metrics.cpu !== undefined && metrics.cpu > thresholds.cpu) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'cpu',
          metrics.cpu,
          thresholds.cpu
        );
      }

      // 메모리 임계값 확인
      if (metrics.memory !== undefined && metrics.memory > thresholds.memory) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'memory',
          metrics.memory,
          thresholds.memory
        );
      }

      // 디스크 임계값 확인
      if (metrics.disk !== undefined && metrics.disk > thresholds.disk) {
        await this.eventBusService.publishMetricThresholdExceeded(
          deviceId,
          'disk',
          metrics.disk,
          thresholds.disk
        );
      }
    } catch (error) {
      this.logger.error('Failed to check metric thresholds', error, { deviceId, metrics });
    }
  }

  /**
   * 전체 장비 헬스 요약 (계약 준수: GET /api/v1/devices/health)
   */
  async getDeviceHealthSummary(): Promise<any> {
    try {
      const allDevices = await this.storageClient.getDevices({ limit: 1000, offset: 0 });
      const allStatuses = await this.cacheService.getAllDeviceStatuses();

      let activeDevices = 0;
      let inactiveDevices = 0;
      let errorDevices = 0;
      let maintenanceDevices = 0;

      for (const device of allDevices.items) {
        const status = allStatuses[device.id];
        if (status) {
          switch (status.status) {
            case 'active': activeDevices++; break;
            case 'error': errorDevices++; break;
            case 'maintenance': maintenanceDevices++; break;
            default: inactiveDevices++;
          }
        } else {
          inactiveDevices++;
        }
      }

      return {
        totalDevices: allDevices.total,
        activeDevices,
        inactiveDevices,
        errorDevices,
        maintenanceDevices,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      this.logger.error('Failed to get device health summary', error);
      throw error;
    }
  }

  /**
   * 장비 목록에 실시간 상태 정보 보강
   */

  /**
   * 장비 상세 조회
   */
  async getDeviceById(id: string): Promise<Device | null> {
    try {
      const device = await this.storageClient.getDeviceById(id);
      
      // 실시간 상태 정보 보강
      const status = await this.cacheService.getDeviceStatus(id);
      
      return {
        ...device,
        status: status?.status || device.status
      };
    } catch (error: any) {
      if (error.message?.includes('not found')) {
        return null;
      }
      throw error;
    }
  }

  /**
   * 장비 정보 수정
   */
  async updateDevice(id: string, updateData: any): Promise<Device> {
    try {
      // Storage API를 통해 업데이트
      const updatedDevice = await this.storageClient.updateDevice(id, updateData);

      // 캐시 정보도 업데이트 (상태가 변경된 경우)
      if (updateData.status) {
        await this.cacheService.setDeviceStatus(id, updateData.status);
      }

      // 이벤트 발행 (기존 패턴 사용)
      // await this.eventBusService.publishDeviceUpdated(id, updateData); // TODO: Fix event format

      return updatedDevice;
    } catch (error) {
      this.logger.error('Failed to update device', { deviceId: id, error });
      throw error;
    }
  }

  /**
   * 장비 삭제
   */
  async deleteDevice(id: string): Promise<void> {
    try {
      // 기존 장비 정보 조회 (이벤트 발행용)
      const existingDevice = await this.storageClient.getDeviceById(id);

      // Storage API를 통해 삭제
      await this.storageClient.deleteDevice(id);

      // 캐시 무효화
      await this.cacheService.invalidateDeviceCache();
      // 이벤트 발행 (기존 패턴 사용)
      await this.eventBusService.publishDeviceDeleted(id, existingDevice);

    } catch (error) {
      this.logger.error('Failed to delete device', { deviceId: id, error });
      throw error;
    }
  }

  private async enrichDevicesWithStatus(devices: Device[]): Promise<Device[]> {
    const enrichedDevices: Device[] = [];

    for (const device of devices) {
      const status = await this.cacheService.getDeviceStatus(device.id);
      
      enrichedDevices.push({
        ...device,
        // 실시간 상태가 있으면 Redis 상태 우선, 없으면 Storage 상태 유지
        status: status?.status || device.status
      });
    }

    return enrichedDevices;
  }
}
