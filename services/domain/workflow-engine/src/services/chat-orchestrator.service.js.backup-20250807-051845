const logger = require('../utils/logger');
const workflowService = require('./workflow.service');
const redisService = require('./redis.service');
const { llmClient, mcpClient, deviceClient } = require('./external.service');
const n8nEngineService = require('./n8n-engine.service');
const { v4: uuidv4 } = require('uuid');

// 🏗️ TASK-WF-004: 워크플로우 템플릿 시스템 import
const { 
  selectWorkflowTemplate, 
  getDefaultTemplate, 
  createExecutionPlan 
} = require('../templates/workflow-templates');

class ChatOrchestrator {
  constructor() {
    this.name = 'ChatOrchestrator';
    this.version = '3.1.0';
    
    // 외부 서비스 클라이언트 주입
    this.llmClient = llmClient;
    this.mcpClient = mcpClient;
    this.deviceClient = deviceClient;
    
    // TASK-WF-002-UPDATED: n8n 엔진 통합
    this.n8nEngine = n8nEngineService;
  }

  // 🎯 메인 채팅 처리 메서드
  async processChat(sessionId, message, context = {}) {
    const startTime = Date.now();
    logger.info(`🎯 processChat 시작: "${message}"`);

    try {
      // 1. 메시지 분류
      const messageType = this.classifyMessage(message);
      logger.info(`🎯 분류 결과: "${message}" → "${messageType}"`);

      // 2. 간단한 메시지 즉시 처리 (워크플로우 건너뛰기)
      if (messageType === 'simple') {
        return await this.handleSimpleMessage(message, startTime);
      }

      // 3. 간단한 계산 즉시 처리
      if (messageType === 'calculation') {
        return await this.handleCalculation(message, startTime);
      }

      // 4. 일반적인 질문 처리
      if (messageType === 'general') {
        return await this.handleGeneralMessage(message, startTime);
      }

      // 5. 복잡한 인프라 작업 워크플로우 처리
      logger.info(`🎯 워크플로우로 진행: ${messageType}`);
      
      try {
        const workflowResult = await this.executeWorkflow(sessionId, message, messageType, context);
        
        return {
          executionId: workflowResult.executionId,
          workflowId: workflowResult.workflowId,
          status: workflowResult.status,
          response: workflowResult.response || '워크플로우가 실행되었습니다.',
          type: 'workflow_response',
          duration: Date.now() - startTime
        };
        
      } catch (workflowError) {
        logger.error(`❌ 워크플로우 실행 실패:`, workflowError);
        
        if (this.isMcpRelatedError(workflowError)) {
          return await this.createMcpErrorResponse(sessionId, message, workflowError);
        }
        
        return await this.createErrorResponse(sessionId, message, workflowError);
      }

    } catch (error) {
      logger.error(`💥 processChat 최종 에러:`, error);
      return await this.createErrorResponse(sessionId, message, error);
    }
  }

  // 🔍 메시지 분류
  classifyMessage(message) {
    const lowerMessage = message.toLowerCase().trim();
    
    // 간단한 인사말 우선 처리
    if (/^(안녕|hello|hi|헬로|하이|좋은|감사|고마워|thank|thanks)/.test(lowerMessage)) {
      return 'simple';
    }
    
    // 도움말 요청 우선 처리
    if (/^(도움|help|헬프|\?)/.test(lowerMessage)) {
      return 'simple';
    }
    
    // 간단한 계산 우선 처리
    if (/^\d+\s*[\+\-\*\/]\s*\d+\s*$/.test(lowerMessage)) {
      return 'calculation';
    }
    
    // 인프라 관련은 구체적이고 충분히 긴 메시지만
    if (/(?:서버|cpu|메모리|재시작|모니터링|백업|상태|확인|실행|관리)/.test(lowerMessage) && 
        lowerMessage.length > 5) {
      return 'infrastructure';
    }
    
    return 'general';
  }

  // 간단한 메시지 처리
  async handleSimpleMessage(message, startTime) {
    logger.info(`🎯 간단한 메시지로 처리 시작`);
    const intent = this.detectSimpleIntent(message);
    let response;
    
    switch (intent) {
      case 'hello':
        response = '안녕하세요! 무엇을 도와드릴까요?\n\n사용 가능한 기능:\n• 서버 모니터링 및 관리\n• 인프라 자동화\n• 간단한 계산\n• 시스템 도움말';
        break;
      case 'thank':
        response = '천만에요! 언제든지 도움이 필요하시면 말씀해주세요.';
        break;
      case 'help':
        response = '도움말:\n\n📊 인프라 모니터링:\n• "서버 상태 확인해줘"\n• "CPU 사용률 보여줘"\n\n⚙️ 시스템 관리:\n• "서버를 재시작해줘"\n• "백업을 실행해줘"\n\n🔢 계산:\n• "5 + 3"\n• "100 / 4"';
        break;
      default:
        response = '네, 무엇을 도와드릴까요?';
    }
    
    return {
      executionId: `simple_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: response,
      type: 'simple_response',
      duration: Date.now() - startTime
    };
  }

  // 계산 메시지 처리
  async handleCalculation(message, startTime) {
    logger.info(`🎯 계산 메시지 처리 시작`);
    const calculationResult = this.performSimpleCalculation(message);
    
    return {
      executionId: `calc_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: calculationResult !== null ? `계산 결과: ${calculationResult}` : '계산을 수행할 수 없습니다. 올바른 수식을 입력해주세요. (예: 5 + 3)',
      type: 'calculation_response',
      duration: Date.now() - startTime
    };
  }

  // 일반 메시지 처리
  async handleGeneralMessage(message, startTime) {
    logger.info(`🎯 일반 메시지 처리 시작`);
    
    return {
      executionId: `general_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: '네, 무엇을 도와드릴까요? 구체적인 요청을 주시면 더 정확히 도움을 드릴 수 있습니다.\n\n예시:\n• "서버 상태 확인해줘"\n• "CPU 사용률이 높은 서버 찾아줘"\n• "백업 실행해줘"',
      type: 'general_response',
      duration: Date.now() - startTime
    };
  }

  // 🚀 워크플로우 실행 - 완전히 재구성
  async executeWorkflow(sessionId, message, messageType, context) {
    const executionId = `workflow_${uuidv4()}`;
    const startTime = Date.now();
    
    logger.info(`🚀 워크플로우 실행 시작 [${executionId}]: "${message}" (타입: ${messageType})`);
    
    try {
      // 1. LLM으로 의도 분석
      logger.info(`🧠 1단계: LLM 의도 분석 시작`);
      const intent = await this.llmClient.analyzeIntent(message, {
        sessionId,
        messageType,
        ...context
      });
      
      logger.info(`✅ 의도 분석 완료:`, {
        intent: intent.intent,
        action: intent.action,
        target: intent.target,
        confidence: intent.confidence
      });

      // 2. 워크플로우 템플릿 선택
      logger.info(`🔧 2단계: 워크플로우 템플릿 선택 시작`);
      const workflowTemplates = require('../templates/workflow-templates');
      const workflowTemplate = workflowTemplates.selectWorkflowTemplate(intent);
      
      if (!workflowTemplate) {
        logger.warn(`⚠️ 적절한 워크플로우 템플릿을 찾을 수 없음: ${intent.intent}`);
        const response = await this.llmClient.generateErrorResponse(
          message, 
          new Error('해당 작업을 수행할 수 있는 워크플로우가 아직 준비되지 않았습니다.')
        );
        
        return {
          executionId,
          workflowId: null,
          status: 'no_workflow',
          response,
          intent
        };
      }

      logger.info(`📋 선택된 워크플로우 템플릿: ${workflowTemplate.name} (${workflowTemplate.steps?.length || 0}개 단계)`);

      // 3. n8n 워크플로우 생성 및 실행
      return await this.executeN8nWorkflow(executionId, workflowTemplate, intent, sessionId, message, startTime);
      
    } catch (error) {
      const errorDuration = Date.now() - startTime;
      logger.error(`💥 워크플로우 실행 중 예외 발생 [${executionId}] (${errorDuration}ms):`, error);

      const errorResponse = await this.generateErrorResponse(message, error);
      
      await this.saveExecutionRecord({
        executionId,
        workflowId: null,
        sessionId,
        status: 'error',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response: errorResponse,
        error: error.message,
        duration: errorDuration
      });

      return {
        executionId,
        workflowId: null,
        status: 'error',
        response: errorResponse,
        error: error.message,
        duration: errorDuration
      };
    }
  }

  // n8n 워크플로우 실행
  async executeN8nWorkflow(executionId, workflowTemplate, intent, sessionId, message, startTime) {
    try {
      logger.info(`🔗 3단계: n8n 워크플로우 생성 시작`);
      
      // n8n에서 워크플로우 생성
      const n8nWorkflow = await this.n8nEngine.createWorkflow({
        ...workflowTemplate,
        name: `${workflowTemplate.name}-${executionId}`
      });
      
      logger.info(`✅ n8n 워크플로우 생성 완료: ID ${n8nWorkflow.id}`);
      
      // n8n에서 워크플로우 실행
      logger.info(`🚀 4단계: n8n 워크플로우 실행 시작`);
      
      const n8nResult = await this.n8nEngine.executeWorkflow(n8nWorkflow.id, {
        intent: intent,
        entities: intent.entities,
        sessionId: sessionId,
        message: message
      });
      
      logger.info(`✅ n8n 워크플로우 실행 완료`, {
        n8nExecutionId: n8nResult.id,
        status: n8nResult.finished ? 'success' : 'failed',
        duration: n8nResult.stoppedAt && n8nResult.startedAt ? 
          new Date(n8nResult.stoppedAt) - new Date(n8nResult.startedAt) : null
      });
      
      // 결과 처리 및 LLM 응답 생성
      const results = this.processN8nResults(n8nResult);
      const response = await this.llmClient.generateResponse(message, results, intent);
      const totalDuration = Date.now() - startTime;

      // 실행 기록 저장
      const finalExecutionData = {
        executionId,
        workflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        sessionId,
        intent,
        templateName: workflowTemplate.name,
        status: n8nResult.finished ? 'completed' : 'failed',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response,
        results,
        duration: totalDuration,
        n8nResult: n8nResult
      };

      await this.saveExecutionToStorage(finalExecutionData);
      
      logger.info(`✅ 워크플로우 실행 완료 (n8n 통합)`, {
        executionId,
        n8nWorkflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        duration: totalDuration,
        status: finalExecutionData.status
      });

      return {
        executionId,
        workflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        status: finalExecutionData.status,
        response,
        intent,
        results
      };
      
    } catch (n8nError) {
      logger.error(`❌ n8n 워크플로우 실행 실패: ${n8nError.message}`, n8nError);
      
      // 폴백 처리
      return await this.executeFallbackWorkflow(executionId, intent, sessionId, message, n8nError, startTime);
    }
  }

  // 폴백 워크플로우 실행 (실제 MCP 통합)
  async executeFallbackWorkflow(executionId, intent, sessionId, message, n8nError, startTime) {
    logger.info(`🔄 폴백: MCP 기반 워크플로우 실행 시도`);
    
    try {
      // 1. 워크플로우 템플릿 선택
      const workflow = await this.selectWorkflow(intent);
      
      if (!workflow) {
        const response = await this.llmClient.generateErrorResponse(
          message, 
          new Error('워크플로우 실행에 실패했고, 대체 방법도 사용할 수 없습니다.')
        );
        
        return {
          executionId,
          workflowId: null,
          status: 'failed',
          response,
          intent,
          error: n8nError.message
        };
      }

      logger.info(`🔄 MCP 기반 폴백 실행 시작 - 워크플로우: ${workflow.name}`);
      
      // 2. 실제 MCP 워크플로우 실행
      const results = await this.executeMCPWorkflowSteps(intent, workflow, sessionId);
      
      // 3. LLM으로 결과 종합 응답 생성
      const response = await this.llmClient.generateResponse(message, results, intent);
      
      // 4. 실행 기록 저장
      await this.saveExecutionToStorage({
        executionId,
        workflowId: workflow.id,
        sessionId,
        intent,
        templateName: workflow.name,
        status: 'completed',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response,
        results,
        duration: Date.now() - startTime,
        fallback: 'mcp_based'
      });

      logger.info(`✅ MCP 기반 폴백 실행 완료 [${executionId}]: ${workflow.name}`);
      
      return {
        executionId,
        workflowId: workflow.id,
        status: 'completed',
        response,
        intent,
        results,
        fallback: 'mcp_based'
      };
      
    } catch (fallbackError) {
      logger.error(`❌ MCP 기반 폴백 실행 실패:`, fallbackError);
      
      const response = await this.llmClient.generateErrorResponse(
        message, 
        new Error('모든 실행 방식이 실패했습니다.')
      );
      
      return {
        executionId,
        workflowId: null,
        status: 'failed',
        response,
        intent,
        error: `n8n: ${n8nError.message}, mcp_fallback: ${fallbackError.message}`
      };
    }
  }

  // 🔧 헬퍼 메소드들
  
  detectSimpleIntent(message) {
    const lowerMessage = message.toLowerCase();
    
    if (/안녕|hello|hi|헬로|하이/.test(lowerMessage)) return 'hello';
    if (/고마워|감사|thank/.test(lowerMessage)) return 'thank';
    if (/도움|help/.test(lowerMessage)) return 'help';
    
    return 'general';
  }

  performSimpleCalculation(message) {
    try {
      const mathExpression = message.match(/(\d+)\s*([\+\-\*\/])\s*(\d+)/);
      if (!mathExpression) return null;

      const [, num1, operator, num2] = mathExpression;
      const a = parseFloat(num1);
      const b = parseFloat(num2);

      switch (operator) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return b !== 0 ? a / b : '0으로 나눌 수 없습니다';
        default: return null;
      }
    } catch (error) {
      logger.warn('계산 처리 오류:', error.message);
      return null;
    }
  }

  // 🚀 TASK-WF-004: 완전한 MCP 워크플로우 오케스트레이션 실행
  async executeMCPWorkflowSteps(intent, workflow, sessionId) {
    const executionContext = {
      sessionId,
      workflow: workflow.id,
      intent,
      startTime: Date.now(),
      steps: []
    };

    logger.info(`🚀 완전한 MCP 워크플로우 실행 시작: ${workflow.name}`);

    try {
      // 1. 실행 계획 수립
      const executionPlan = await this.createExecutionPlan(intent, workflow);
      logger.info(`📋 실행 계획: ${executionPlan.steps.length}개 단계, 병렬처리: ${executionPlan.parallel}`);

      // 2. 필요한 장비/도구 사전 확인
      await this.validateExecutionRequirements(executionPlan);

      // 3. 단계별 실행
      const results = [];
      if (executionPlan.parallel) {
        results.push(...await this.executeStepsInParallel(executionPlan.steps, executionContext));
      } else {
        results.push(...await this.executeStepsSequentially(executionPlan.steps, executionContext));
      }

      // 4. 결과 정규화 및 검증
      const normalizedResults = await this.normalizeExecutionResults(results);

      logger.info(`✅ MCP 워크플로우 완료: ${results.length}개 단계 실행`);

      return {
        workflow: workflow.id,
        executionPlan,
        steps: results,
        normalizedResults,
        summary: this.createExecutionSummary(results),
        duration: Date.now() - executionContext.startTime
      };

    } catch (error) {
      logger.error(`❌ MCP 워크플로우 실행 실패: ${error.message}`, error);

      // 부분 성공 결과라도 반환
      return {
        workflow: workflow.id,
        steps: executionContext.steps,
        status: 'partial_failure',
        error: error.message,
        duration: Date.now() - executionContext.startTime
      };
    }
  }

  // 🔧 의도별 MCP 도구 실행
  async executeMCPToolsForIntent(intent, serverId, sessionId) {
    const results = [];
    logger.info(`🎯 의도별 MCP 도구 실행: ${intent.intent}`);

    try {
      switch (intent.intent) {
        case 'monitor_servers':
        case 'monitor_and_restart':
          return await this.executeServerMonitoringTools(intent, serverId, sessionId);
          
        case 'restart_service':
          return await this.executeServiceRestartTools(intent, serverId, sessionId);
          
        case 'backup_data':
          return await this.executeBackupTools(intent, serverId, sessionId);
          
        default:
          // 기본적으로 서버 상태 확인
          return await this.executeDefaultServerCheck(intent, serverId, sessionId);
      }
    } catch (error) {
      logger.error(`❌ 의도별 MCP 도구 실행 실패:`, error);
      results.push({
        type: 'error',
        intent: intent.intent,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  isMcpRelatedError(error) {
    const errorMessage = error.message || error.toString();
    return errorMessage.includes('UUID') || 
           errorMessage.includes('uuid') || 
           errorMessage.includes('MCP') || 
           errorMessage.includes('default-mcp-server');
  }

  // 🔧 서버 모니터링 도구 실행
  async executeServerMonitoringTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`🖥️ 서버 모니터링 도구 실행 시작`);

    try {
      // 1. 등록된 디바이스 목록 조회
      const devices = await this.deviceClient.getDevices({ status: 'active' });
      logger.info(`📋 활성 디바이스: ${devices.items?.length || 0}개`);

      if (!devices.items || devices.items.length === 0) {
        results.push({
          type: 'info',
          message: '모니터링할 활성 디바이스가 없습니다',
          timestamp: new Date().toISOString()
        });
        return results;
      }

      // 2. 시스템 프로세스 상태 확인 (로컬 시스템)
      try {
        logger.info(`🔍 로컬 시스템 프로세스 상태 확인`);
        
        const processResult = await this.mcpClient.executeTool(
          serverId,
          'list_processes',
          {},
          false // 동기 실행
        );

        results.push({
          type: 'system_status',
          target: 'local_system',
          status: 'checked',
          processCount: this.parseProcessCount(processResult),
          timestamp: new Date().toISOString(),
          details: this.formatProcessResult(processResult)
        });

      } catch (processError) {
        logger.warn(`⚠️ 로컬 시스템 프로세스 확인 실패:`, processError);
        
        results.push({
          type: 'system_error',
          target: 'local_system',
          error: processError.message,
          timestamp: new Date().toISOString()
        });
      }

      // 3. Docker 컨테이너 상태 확인
      try {
        logger.info(`🐳 Docker 컨테이너 상태 확인`);
        
        const dockerResult = await this.mcpClient.executeTool(
          serverId,
          'start_process',
          {
            command: 'docker ps --format "table {{.Names}}\\t{{.Status}}" | grep automation',
            timeout_ms: 10000
          },
          false
        );

        results.push({
          type: 'docker_status',
          target: 'automation_containers',
          status: 'checked',
          timestamp: new Date().toISOString(),
          details: this.formatDockerResult(dockerResult)
        });

      } catch (dockerError) {
        logger.warn(`⚠️ Docker 컨테이너 상태 확인 실패:`, dockerError);
        
        results.push({
          type: 'docker_error',
          target: 'automation_containers',
          error: dockerError.message,
          timestamp: new Date().toISOString()
        });
      }

      // 4. 등록된 디바이스 정보 포함
      for (const device of devices.items.slice(0, 3)) { // 최대 3개 디바이스
        results.push({
          type: 'device_info',
          deviceId: device.id,
          deviceName: device.name,
          host: device.connectionInfo?.host || 'unknown',
          status: device.status,
          type: device.type,
          timestamp: new Date().toISOString()
        });
      }

      logger.info(`✅ 서버 모니터링 완료: ${results.length}개 결과`);
      return results;

    } catch (error) {
      logger.error(`❌ 서버 모니터링 도구 실행 실패:`, error);
      results.push({
        type: 'monitoring_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // 🔧 기본 서버 확인
  async executeDefaultServerCheck(intent, serverId, sessionId) {
    logger.info(`🔍 기본 서버 상태 확인 실행`);
    return await this.executeServerMonitoringTools(intent, serverId, sessionId);
  }

  // 🔧 서비스 재시작 도구 실행 
  async executeServiceRestartTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`🔄 서비스 재시작 도구 실행 시작`);

    try {
      // Docker 컨테이너 재시작 시뮬레이션
      const serviceName = intent.entities?.service || 'automation-workflow-engine';
      
      results.push({
        type: 'service_restart_simulated',
        service: serviceName,
        message: `${serviceName} 서비스 재시작이 시뮬레이션되었습니다. 실제 환경에서는 docker restart 명령이 실행됩니다.`,
        timestamp: new Date().toISOString()
      });

      logger.info(`✅ 서비스 재시작 시뮬레이션 완료`);
      return results;

    } catch (error) {
      logger.error(`❌ 서비스 재시작 도구 실행 실패:`, error);
      results.push({
        type: 'restart_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // 🔧 백업 도구 실행
  async executeBackupTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`💾 백업 도구 실행 시작`);

    try {
      // 백업 스크립트 실행 시뮬레이션
      results.push({
        type: 'backup_simulated',
        message: '데이터 백업이 시뮬레이션되었습니다. 실제 환경에서는 백업 스크립트가 실행됩니다.',
        timestamp: new Date().toISOString()
      });

      logger.info(`✅ 백업 시뮬레이션 완료`);
      return results;

    } catch (error) {
      logger.error(`❌ 백업 도구 실행 실패:`, error);
      results.push({
        type: 'backup_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // 🔧 헬퍼: 프로세스 결과 파싱
  parseProcessCount(processResult) {
    try {
      if (processResult && processResult.data && typeof processResult.data === 'string') {
        const lines = processResult.data.split('\n').filter(line => line.trim());
        return Math.max(0, lines.length - 1); // 헤더 제외
      }
      return 0;
    } catch (error) {
      logger.warn('프로세스 결과 파싱 오류:', error);
      return 0;
    }
  }

  // 🔧 헬퍼: 프로세스 결과 포맷팅
  formatProcessResult(processResult) {
    try {
      if (processResult && processResult.data) {
        const lines = processResult.data.split('\n').slice(0, 5); // 상위 5개만
        return lines.join('\n');
      }
      return 'No process data available';
    } catch (error) {
      logger.warn('프로세스 결과 포맷팅 오류:', error);
      return 'Process data formatting error';
    }
  }

  // 🔧 헬퍼: Docker 결과 포맷팅
  formatDockerResult(dockerResult) {
    try {
      if (dockerResult && dockerResult.data) {
        return dockerResult.data.substring(0, 500); // 최대 500자
      }
      return 'No docker data available';
    } catch (error) {
      logger.warn('Docker 결과 포맷팅 오류:', error);
      return 'Docker data formatting error';
    }
  }

  async createMcpErrorResponse(sessionId, message, error) {
    logger.warn(`🔄 MCP 에러 폴백 응답 생성: ${error.message}`);
    
    const isUuidError = error.message.includes('UUID') || error.message.includes('uuid');
    
    let response;
    if (isUuidError) {
      response = '죄송합니다. 시스템 초기화 중입니다. 잠시 후 다시 시도해주세요.\n\n현재 사용 가능한 기능:\n• 일반적인 질문과 답변\n• 간단한 계산\n• 시스템 도움말';
    } else {
      response = '일시적으로 인프라 관리 기능에 접근할 수 없습니다. 관리자에게 문의하거나 잠시 후 다시 시도해주세요.';
    }

    return {
      executionId: `mcp_error_${uuidv4()}`,
      workflowId: null,
      status: 'failed',
      response: response,
      type: 'error_response',
      error: {
        type: 'mcp_error',
        message: error.message,
        recoverable: true
      },
      duration: 0
    };
  }

  async createErrorResponse(sessionId, message, error) {
    logger.error(`💥 최종 에러 응답 생성: ${error.message}`);
    
    return {
      executionId: `final_error_${uuidv4()}`,
      workflowId: null,
      status: 'failed',
      response: '시스템에 일시적인 문제가 발생했습니다. 잠시 후 다시 시도해주세요.',
      type: 'system_error',
      error: {
        type: 'system_error',
        message: error.message,
        recoverable: false
      },
      duration: 0
    };
  }

  async generateErrorResponse(message, error) {
    try {
      return await this.llmClient.generateErrorResponse(message, error);
    } catch (llmError) {
      logger.error(`❌ LLM 에러 응답 생성 실패:`, llmError);
      return `죄송합니다. "${message}" 요청을 처리하는 중에 문제가 발생했습니다. 잠시 후 다시 시도해주세요.`;
    }
  }

  // 워크플로우 선택 (간소화된 버전)
  async selectWorkflow(intent) {
    try {
      return {
        id: `fallback_${Date.now()}`,
        name: 'Fallback Workflow',
        description: '폴백 워크플로우'
      };
    } catch (error) {
      logger.error(`❌ 워크플로우 선택 실패:`, error);
      return null;
    }
  }

  // n8n 결과 처리
  processN8nResults(n8nResult) {
    logger.info(`📊 n8n 결과 처리 시작: ${n8nResult.id}`);
    
    try {
      const runData = n8nResult.data?.resultData?.runData || {};
      const results = [];
      
      Object.entries(runData).forEach(([nodeName, nodeData], index) => {
        const nodeResult = {
          stepIndex: index,
          stepName: nodeName,
          success: nodeData && nodeData.length > 0,
          data: nodeData || null,
          duration: 0
        };
        
        results.push(nodeResult);
      });
      
      const summary = {
        totalNodes: results.length,
        successfulNodes: results.filter(r => r.success).length,
        failedNodes: results.filter(r => !r.success).length,
        overallSuccess: results.length > 0 && results.some(r => r.success)
      };
      
      return {
        steps: results,
        summary: summary,
        n8nExecutionId: n8nResult.id
      };
      
    } catch (processingError) {
      logger.error(`❌ n8n 결과 처리 실패:`, processingError);
      
      return {
        steps: [{
          stepIndex: 0,
          stepName: 'n8n-execution',
          success: false,
          error: processingError.message,
          duration: 0
        }],
        summary: {
          totalNodes: 1,
          successfulNodes: 0,
          failedNodes: 1,
          overallSuccess: false
        },
        n8nExecutionId: n8nResult.id
      };
    }
  }

  // 실행 결과 저장
  async saveExecutionToStorage(executionData) {
    try {
      logger.info(`💾 실행 결과 저장: ${executionData.executionId}`);
      
      const executionRecord = {
        id: executionData.executionId,
        workflow_id: executionData.workflowId,
        n8n_execution_id: executionData.n8nExecutionId,
        session_id: executionData.sessionId,
        status: executionData.status,
        intent: JSON.stringify(executionData.intent),
        template_name: executionData.templateName,
        started_at: executionData.startedAt,
        completed_at: executionData.completedAt,
        response_text: executionData.response,
        duration_ms: executionData.duration,
        created_at: new Date()
      };
      
      await workflowService.saveExecution(executionRecord);
      
      logger.info(`✅ 실행 결과 저장 완료: ${executionData.executionId}`);
      
    } catch (storageError) {
      logger.error(`❌ 실행 결과 저장 실패: ${executionData.executionId}`, storageError);
    }
  }

  async saveExecutionRecord(executionData) {
    try {
      await workflowService.createExecution(executionData);
      await redisService.addSessionExecution(
        executionData.sessionId, 
        executionData.executionId
      );
    } catch (error) {
      logger.error(`❌ 실행 기록 저장 실패:`, error);
    }
  }

  // 🚀 TASK-WF-004: 고급 워크플로우 오케스트레이션 메서드들

  /**
   * 실행 계획 생성
   */
  async createExecutionPlan(intent, workflow) {
    logger.info(`📋 실행 계획 생성: ${workflow.name}`);
    
    const plan = createExecutionPlan(intent, workflow);
    
    // 의도에서 추출된 엔티티 정보 추가
    plan.context = {
      intent: intent.intent,
      entities: intent.entities || {},
      originalMessage: intent.original_message
    };
    
    return plan;
  }

  /**
   * 실행 요구사항 검증
   */
  async validateExecutionRequirements(executionPlan) {
    logger.info(`🔍 실행 요구사항 검증 중...`);

    // 1. MCP 서버 가용성 확인
    const mcpServers = await this.mcpClient.getServers();
    if (!mcpServers.items || mcpServers.items.length === 0) {
      throw new Error('실행에 필요한 MCP 서버가 없습니다');
    }

    // 2. desktop-commander 서버 확인
    const desktopCommander = mcpServers.items.find(server => 
      server.name === 'desktop-commander' && server.status === 'active'
    );
    
    if (!desktopCommander) {
      throw new Error('desktop-commander MCP 서버를 사용할 수 없습니다');
    }

    logger.info(`✅ 실행 요구사항 검증 완료`);
  }

  /**
   * 병렬 단계 실행
   */
  async executeStepsInParallel(steps, context) {
    logger.info(`⚡ 병렬 실행 시작: ${steps.length}개 단계`);

    const promises = steps.map(async (step, index) => {
      const stepContext = { ...context, stepIndex: index, step };

      try {
        // 실시간 진행 상황 보고
        await this.sendStepProgress(context.sessionId, 'started', step);

        const result = await this.executeWorkflowStep(step, stepContext);

        await this.sendStepProgress(context.sessionId, 'completed', step, result);

        return result;
      } catch (stepError) {
        logger.error(`❌ 병렬 단계 ${index} 실행 실패:`, stepError);

        await this.sendStepProgress(context.sessionId, 'failed', step, null, stepError);

        return {
          stepIndex: index,
          step,
          success: false,
          error: stepError.message,
          duration: 0
        };
      }
    });

    const results = await Promise.allSettled(promises);

    return results.map((result, index) => ({
      stepIndex: index,
      success: result.status === 'fulfilled',
      data: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason.message : null
    }));
  }

  /**
   * 순차 단계 실행
   */
  async executeStepsSequentially(steps, context) {
    logger.info(`🔄 순차 실행 시작: ${steps.length}개 단계`);

    const results = [];

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      const stepContext = { ...context, stepIndex: i, step };

      try {
        await this.sendStepProgress(context.sessionId, 'started', step);

        const result = await this.executeWorkflowStep(step, stepContext);

        await this.sendStepProgress(context.sessionId, 'completed', step, result);

        results.push({
          stepIndex: i,
          step,
          success: true,
          data: result,
          duration: result.duration || 0
        });

        // 이전 단계 결과를 다음 단계 컨텍스트에 추가
        stepContext.previousResults = results;

      } catch (stepError) {
        logger.error(`❌ 순차 단계 ${i} 실행 실패:`, stepError);

        await this.sendStepProgress(context.sessionId, 'failed', step, null, stepError);

        // 실패 처리 전략 결정
        const recoveryStrategy = await this.determineRecoveryStrategy(step, stepError, stepContext);

        if (recoveryStrategy === 'abort') {
          logger.warn(`🛑 순차 실행 중단: ${step.name}`);
          break;
        } else if (recoveryStrategy === 'skip') {
          logger.warn(`⏭️ 단계 건너뛰기: ${step.name}`);
          results.push({
            stepIndex: i,
            step,
            success: false,
            error: stepError.message,
            skipped: true
          });
        } else if (recoveryStrategy === 'retry') {
          // 재시도 로직 (간단한 버전)
          i--; // 현재 단계 재시도
        }
      }
    }

    return results;
  }
}

module.exports = new ChatOrchestrator();
