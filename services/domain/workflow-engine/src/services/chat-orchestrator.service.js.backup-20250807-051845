const logger = require('../utils/logger');
const workflowService = require('./workflow.service');
const redisService = require('./redis.service');
const { llmClient, mcpClient, deviceClient } = require('./external.service');
const n8nEngineService = require('./n8n-engine.service');
const { v4: uuidv4 } = require('uuid');

// ðŸ—ï¸ TASK-WF-004: ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì‹œìŠ¤í…œ import
const { 
  selectWorkflowTemplate, 
  getDefaultTemplate, 
  createExecutionPlan 
} = require('../templates/workflow-templates');

class ChatOrchestrator {
  constructor() {
    this.name = 'ChatOrchestrator';
    this.version = '3.1.0';
    
    // ì™¸ë¶€ ì„œë¹„ìŠ¤ í´ë¼ì´ì–¸íŠ¸ ì£¼ìž…
    this.llmClient = llmClient;
    this.mcpClient = mcpClient;
    this.deviceClient = deviceClient;
    
    // TASK-WF-002-UPDATED: n8n ì—”ì§„ í†µí•©
    this.n8nEngine = n8nEngineService;
  }

  // ðŸŽ¯ ë©”ì¸ ì±„íŒ… ì²˜ë¦¬ ë©”ì„œë“œ
  async processChat(sessionId, message, context = {}) {
    const startTime = Date.now();
    logger.info(`ðŸŽ¯ processChat ì‹œìž‘: "${message}"`);

    try {
      // 1. ë©”ì‹œì§€ ë¶„ë¥˜
      const messageType = this.classifyMessage(message);
      logger.info(`ðŸŽ¯ ë¶„ë¥˜ ê²°ê³¼: "${message}" â†’ "${messageType}"`);

      // 2. ê°„ë‹¨í•œ ë©”ì‹œì§€ ì¦‰ì‹œ ì²˜ë¦¬ (ì›Œí¬í”Œë¡œìš° ê±´ë„ˆë›°ê¸°)
      if (messageType === 'simple') {
        return await this.handleSimpleMessage(message, startTime);
      }

      // 3. ê°„ë‹¨í•œ ê³„ì‚° ì¦‰ì‹œ ì²˜ë¦¬
      if (messageType === 'calculation') {
        return await this.handleCalculation(message, startTime);
      }

      // 4. ì¼ë°˜ì ì¸ ì§ˆë¬¸ ì²˜ë¦¬
      if (messageType === 'general') {
        return await this.handleGeneralMessage(message, startTime);
      }

      // 5. ë³µìž¡í•œ ì¸í”„ë¼ ìž‘ì—… ì›Œí¬í”Œë¡œìš° ì²˜ë¦¬
      logger.info(`ðŸŽ¯ ì›Œí¬í”Œë¡œìš°ë¡œ ì§„í–‰: ${messageType}`);
      
      try {
        const workflowResult = await this.executeWorkflow(sessionId, message, messageType, context);
        
        return {
          executionId: workflowResult.executionId,
          workflowId: workflowResult.workflowId,
          status: workflowResult.status,
          response: workflowResult.response || 'ì›Œí¬í”Œë¡œìš°ê°€ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.',
          type: 'workflow_response',
          duration: Date.now() - startTime
        };
        
      } catch (workflowError) {
        logger.error(`âŒ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨:`, workflowError);
        
        if (this.isMcpRelatedError(workflowError)) {
          return await this.createMcpErrorResponse(sessionId, message, workflowError);
        }
        
        return await this.createErrorResponse(sessionId, message, workflowError);
      }

    } catch (error) {
      logger.error(`ðŸ’¥ processChat ìµœì¢… ì—ëŸ¬:`, error);
      return await this.createErrorResponse(sessionId, message, error);
    }
  }

  // ðŸ” ë©”ì‹œì§€ ë¶„ë¥˜
  classifyMessage(message) {
    const lowerMessage = message.toLowerCase().trim();
    
    // ê°„ë‹¨í•œ ì¸ì‚¬ë§ ìš°ì„  ì²˜ë¦¬
    if (/^(ì•ˆë…•|hello|hi|í—¬ë¡œ|í•˜ì´|ì¢‹ì€|ê°ì‚¬|ê³ ë§ˆì›Œ|thank|thanks)/.test(lowerMessage)) {
      return 'simple';
    }
    
    // ë„ì›€ë§ ìš”ì²­ ìš°ì„  ì²˜ë¦¬
    if (/^(ë„ì›€|help|í—¬í”„|\?)/.test(lowerMessage)) {
      return 'simple';
    }
    
    // ê°„ë‹¨í•œ ê³„ì‚° ìš°ì„  ì²˜ë¦¬
    if (/^\d+\s*[\+\-\*\/]\s*\d+\s*$/.test(lowerMessage)) {
      return 'calculation';
    }
    
    // ì¸í”„ë¼ ê´€ë ¨ì€ êµ¬ì²´ì ì´ê³  ì¶©ë¶„ížˆ ê¸´ ë©”ì‹œì§€ë§Œ
    if (/(?:ì„œë²„|cpu|ë©”ëª¨ë¦¬|ìž¬ì‹œìž‘|ëª¨ë‹ˆí„°ë§|ë°±ì—…|ìƒíƒœ|í™•ì¸|ì‹¤í–‰|ê´€ë¦¬)/.test(lowerMessage) && 
        lowerMessage.length > 5) {
      return 'infrastructure';
    }
    
    return 'general';
  }

  // ê°„ë‹¨í•œ ë©”ì‹œì§€ ì²˜ë¦¬
  async handleSimpleMessage(message, startTime) {
    logger.info(`ðŸŽ¯ ê°„ë‹¨í•œ ë©”ì‹œì§€ë¡œ ì²˜ë¦¬ ì‹œìž‘`);
    const intent = this.detectSimpleIntent(message);
    let response;
    
    switch (intent) {
      case 'hello':
        response = 'ì•ˆë…•í•˜ì„¸ìš”! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?\n\nì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ëŠ¥:\nâ€¢ ì„œë²„ ëª¨ë‹ˆí„°ë§ ë° ê´€ë¦¬\nâ€¢ ì¸í”„ë¼ ìžë™í™”\nâ€¢ ê°„ë‹¨í•œ ê³„ì‚°\nâ€¢ ì‹œìŠ¤í…œ ë„ì›€ë§';
        break;
      case 'thank':
        response = 'ì²œë§Œì—ìš”! ì–¸ì œë“ ì§€ ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”.';
        break;
      case 'help':
        response = 'ë„ì›€ë§:\n\nðŸ“Š ì¸í”„ë¼ ëª¨ë‹ˆí„°ë§:\nâ€¢ "ì„œë²„ ìƒíƒœ í™•ì¸í•´ì¤˜"\nâ€¢ "CPU ì‚¬ìš©ë¥  ë³´ì—¬ì¤˜"\n\nâš™ï¸ ì‹œìŠ¤í…œ ê´€ë¦¬:\nâ€¢ "ì„œë²„ë¥¼ ìž¬ì‹œìž‘í•´ì¤˜"\nâ€¢ "ë°±ì—…ì„ ì‹¤í–‰í•´ì¤˜"\n\nðŸ”¢ ê³„ì‚°:\nâ€¢ "5 + 3"\nâ€¢ "100 / 4"';
        break;
      default:
        response = 'ë„¤, ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?';
    }
    
    return {
      executionId: `simple_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: response,
      type: 'simple_response',
      duration: Date.now() - startTime
    };
  }

  // ê³„ì‚° ë©”ì‹œì§€ ì²˜ë¦¬
  async handleCalculation(message, startTime) {
    logger.info(`ðŸŽ¯ ê³„ì‚° ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œìž‘`);
    const calculationResult = this.performSimpleCalculation(message);
    
    return {
      executionId: `calc_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: calculationResult !== null ? `ê³„ì‚° ê²°ê³¼: ${calculationResult}` : 'ê³„ì‚°ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ ìˆ˜ì‹ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”. (ì˜ˆ: 5 + 3)',
      type: 'calculation_response',
      duration: Date.now() - startTime
    };
  }

  // ì¼ë°˜ ë©”ì‹œì§€ ì²˜ë¦¬
  async handleGeneralMessage(message, startTime) {
    logger.info(`ðŸŽ¯ ì¼ë°˜ ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œìž‘`);
    
    return {
      executionId: `general_${uuidv4()}`,
      workflowId: null,
      status: 'completed',
      response: 'ë„¤, ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? êµ¬ì²´ì ì¸ ìš”ì²­ì„ ì£¼ì‹œë©´ ë” ì •í™•ížˆ ë„ì›€ì„ ë“œë¦´ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\nì˜ˆì‹œ:\nâ€¢ "ì„œë²„ ìƒíƒœ í™•ì¸í•´ì¤˜"\nâ€¢ "CPU ì‚¬ìš©ë¥ ì´ ë†’ì€ ì„œë²„ ì°¾ì•„ì¤˜"\nâ€¢ "ë°±ì—… ì‹¤í–‰í•´ì¤˜"',
      type: 'general_response',
      duration: Date.now() - startTime
    };
  }

  // ðŸš€ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ - ì™„ì „ížˆ ìž¬êµ¬ì„±
  async executeWorkflow(sessionId, message, messageType, context) {
    const executionId = `workflow_${uuidv4()}`;
    const startTime = Date.now();
    
    logger.info(`ðŸš€ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹œìž‘ [${executionId}]: "${message}" (íƒ€ìž…: ${messageType})`);
    
    try {
      // 1. LLMìœ¼ë¡œ ì˜ë„ ë¶„ì„
      logger.info(`ðŸ§  1ë‹¨ê³„: LLM ì˜ë„ ë¶„ì„ ì‹œìž‘`);
      const intent = await this.llmClient.analyzeIntent(message, {
        sessionId,
        messageType,
        ...context
      });
      
      logger.info(`âœ… ì˜ë„ ë¶„ì„ ì™„ë£Œ:`, {
        intent: intent.intent,
        action: intent.action,
        target: intent.target,
        confidence: intent.confidence
      });

      // 2. ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì„ íƒ
      logger.info(`ðŸ”§ 2ë‹¨ê³„: ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì„ íƒ ì‹œìž‘`);
      const workflowTemplates = require('../templates/workflow-templates');
      const workflowTemplate = workflowTemplates.selectWorkflowTemplate(intent);
      
      if (!workflowTemplate) {
        logger.warn(`âš ï¸ ì ì ˆí•œ ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${intent.intent}`);
        const response = await this.llmClient.generateErrorResponse(
          message, 
          new Error('í•´ë‹¹ ìž‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìžˆëŠ” ì›Œí¬í”Œë¡œìš°ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
        );
        
        return {
          executionId,
          workflowId: null,
          status: 'no_workflow',
          response,
          intent
        };
      }

      logger.info(`ðŸ“‹ ì„ íƒëœ ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿: ${workflowTemplate.name} (${workflowTemplate.steps?.length || 0}ê°œ ë‹¨ê³„)`);

      // 3. n8n ì›Œí¬í”Œë¡œìš° ìƒì„± ë° ì‹¤í–‰
      return await this.executeN8nWorkflow(executionId, workflowTemplate, intent, sessionId, message, startTime);
      
    } catch (error) {
      const errorDuration = Date.now() - startTime;
      logger.error(`ðŸ’¥ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ [${executionId}] (${errorDuration}ms):`, error);

      const errorResponse = await this.generateErrorResponse(message, error);
      
      await this.saveExecutionRecord({
        executionId,
        workflowId: null,
        sessionId,
        status: 'error',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response: errorResponse,
        error: error.message,
        duration: errorDuration
      });

      return {
        executionId,
        workflowId: null,
        status: 'error',
        response: errorResponse,
        error: error.message,
        duration: errorDuration
      };
    }
  }

  // n8n ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
  async executeN8nWorkflow(executionId, workflowTemplate, intent, sessionId, message, startTime) {
    try {
      logger.info(`ðŸ”— 3ë‹¨ê³„: n8n ì›Œí¬í”Œë¡œìš° ìƒì„± ì‹œìž‘`);
      
      // n8nì—ì„œ ì›Œí¬í”Œë¡œìš° ìƒì„±
      const n8nWorkflow = await this.n8nEngine.createWorkflow({
        ...workflowTemplate,
        name: `${workflowTemplate.name}-${executionId}`
      });
      
      logger.info(`âœ… n8n ì›Œí¬í”Œë¡œìš° ìƒì„± ì™„ë£Œ: ID ${n8nWorkflow.id}`);
      
      // n8nì—ì„œ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
      logger.info(`ðŸš€ 4ë‹¨ê³„: n8n ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹œìž‘`);
      
      const n8nResult = await this.n8nEngine.executeWorkflow(n8nWorkflow.id, {
        intent: intent,
        entities: intent.entities,
        sessionId: sessionId,
        message: message
      });
      
      logger.info(`âœ… n8n ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì™„ë£Œ`, {
        n8nExecutionId: n8nResult.id,
        status: n8nResult.finished ? 'success' : 'failed',
        duration: n8nResult.stoppedAt && n8nResult.startedAt ? 
          new Date(n8nResult.stoppedAt) - new Date(n8nResult.startedAt) : null
      });
      
      // ê²°ê³¼ ì²˜ë¦¬ ë° LLM ì‘ë‹µ ìƒì„±
      const results = this.processN8nResults(n8nResult);
      const response = await this.llmClient.generateResponse(message, results, intent);
      const totalDuration = Date.now() - startTime;

      // ì‹¤í–‰ ê¸°ë¡ ì €ìž¥
      const finalExecutionData = {
        executionId,
        workflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        sessionId,
        intent,
        templateName: workflowTemplate.name,
        status: n8nResult.finished ? 'completed' : 'failed',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response,
        results,
        duration: totalDuration,
        n8nResult: n8nResult
      };

      await this.saveExecutionToStorage(finalExecutionData);
      
      logger.info(`âœ… ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì™„ë£Œ (n8n í†µí•©)`, {
        executionId,
        n8nWorkflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        duration: totalDuration,
        status: finalExecutionData.status
      });

      return {
        executionId,
        workflowId: n8nWorkflow.id,
        n8nExecutionId: n8nResult.id,
        status: finalExecutionData.status,
        response,
        intent,
        results
      };
      
    } catch (n8nError) {
      logger.error(`âŒ n8n ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨: ${n8nError.message}`, n8nError);
      
      // í´ë°± ì²˜ë¦¬
      return await this.executeFallbackWorkflow(executionId, intent, sessionId, message, n8nError, startTime);
    }
  }

  // í´ë°± ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ (ì‹¤ì œ MCP í†µí•©)
  async executeFallbackWorkflow(executionId, intent, sessionId, message, n8nError, startTime) {
    logger.info(`ðŸ”„ í´ë°±: MCP ê¸°ë°˜ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹œë„`);
    
    try {
      // 1. ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì„ íƒ
      const workflow = await this.selectWorkflow(intent);
      
      if (!workflow) {
        const response = await this.llmClient.generateErrorResponse(
          message, 
          new Error('ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ì— ì‹¤íŒ¨í–ˆê³ , ëŒ€ì²´ ë°©ë²•ë„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')
        );
        
        return {
          executionId,
          workflowId: null,
          status: 'failed',
          response,
          intent,
          error: n8nError.message
        };
      }

      logger.info(`ðŸ”„ MCP ê¸°ë°˜ í´ë°± ì‹¤í–‰ ì‹œìž‘ - ì›Œí¬í”Œë¡œìš°: ${workflow.name}`);
      
      // 2. ì‹¤ì œ MCP ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
      const results = await this.executeMCPWorkflowSteps(intent, workflow, sessionId);
      
      // 3. LLMìœ¼ë¡œ ê²°ê³¼ ì¢…í•© ì‘ë‹µ ìƒì„±
      const response = await this.llmClient.generateResponse(message, results, intent);
      
      // 4. ì‹¤í–‰ ê¸°ë¡ ì €ìž¥
      await this.saveExecutionToStorage({
        executionId,
        workflowId: workflow.id,
        sessionId,
        intent,
        templateName: workflow.name,
        status: 'completed',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        response,
        results,
        duration: Date.now() - startTime,
        fallback: 'mcp_based'
      });

      logger.info(`âœ… MCP ê¸°ë°˜ í´ë°± ì‹¤í–‰ ì™„ë£Œ [${executionId}]: ${workflow.name}`);
      
      return {
        executionId,
        workflowId: workflow.id,
        status: 'completed',
        response,
        intent,
        results,
        fallback: 'mcp_based'
      };
      
    } catch (fallbackError) {
      logger.error(`âŒ MCP ê¸°ë°˜ í´ë°± ì‹¤í–‰ ì‹¤íŒ¨:`, fallbackError);
      
      const response = await this.llmClient.generateErrorResponse(
        message, 
        new Error('ëª¨ë“  ì‹¤í–‰ ë°©ì‹ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
      );
      
      return {
        executionId,
        workflowId: null,
        status: 'failed',
        response,
        intent,
        error: `n8n: ${n8nError.message}, mcp_fallback: ${fallbackError.message}`
      };
    }
  }

  // ðŸ”§ í—¬í¼ ë©”ì†Œë“œë“¤
  
  detectSimpleIntent(message) {
    const lowerMessage = message.toLowerCase();
    
    if (/ì•ˆë…•|hello|hi|í—¬ë¡œ|í•˜ì´/.test(lowerMessage)) return 'hello';
    if (/ê³ ë§ˆì›Œ|ê°ì‚¬|thank/.test(lowerMessage)) return 'thank';
    if (/ë„ì›€|help/.test(lowerMessage)) return 'help';
    
    return 'general';
  }

  performSimpleCalculation(message) {
    try {
      const mathExpression = message.match(/(\d+)\s*([\+\-\*\/])\s*(\d+)/);
      if (!mathExpression) return null;

      const [, num1, operator, num2] = mathExpression;
      const a = parseFloat(num1);
      const b = parseFloat(num2);

      switch (operator) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return b !== 0 ? a / b : '0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
        default: return null;
      }
    } catch (error) {
      logger.warn('ê³„ì‚° ì²˜ë¦¬ ì˜¤ë¥˜:', error.message);
      return null;
    }
  }

  // ðŸš€ TASK-WF-004: ì™„ì „í•œ MCP ì›Œí¬í”Œë¡œìš° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ì‹¤í–‰
  async executeMCPWorkflowSteps(intent, workflow, sessionId) {
    const executionContext = {
      sessionId,
      workflow: workflow.id,
      intent,
      startTime: Date.now(),
      steps: []
    };

    logger.info(`ðŸš€ ì™„ì „í•œ MCP ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹œìž‘: ${workflow.name}`);

    try {
      // 1. ì‹¤í–‰ ê³„íš ìˆ˜ë¦½
      const executionPlan = await this.createExecutionPlan(intent, workflow);
      logger.info(`ðŸ“‹ ì‹¤í–‰ ê³„íš: ${executionPlan.steps.length}ê°œ ë‹¨ê³„, ë³‘ë ¬ì²˜ë¦¬: ${executionPlan.parallel}`);

      // 2. í•„ìš”í•œ ìž¥ë¹„/ë„êµ¬ ì‚¬ì „ í™•ì¸
      await this.validateExecutionRequirements(executionPlan);

      // 3. ë‹¨ê³„ë³„ ì‹¤í–‰
      const results = [];
      if (executionPlan.parallel) {
        results.push(...await this.executeStepsInParallel(executionPlan.steps, executionContext));
      } else {
        results.push(...await this.executeStepsSequentially(executionPlan.steps, executionContext));
      }

      // 4. ê²°ê³¼ ì •ê·œí™” ë° ê²€ì¦
      const normalizedResults = await this.normalizeExecutionResults(results);

      logger.info(`âœ… MCP ì›Œí¬í”Œë¡œìš° ì™„ë£Œ: ${results.length}ê°œ ë‹¨ê³„ ì‹¤í–‰`);

      return {
        workflow: workflow.id,
        executionPlan,
        steps: results,
        normalizedResults,
        summary: this.createExecutionSummary(results),
        duration: Date.now() - executionContext.startTime
      };

    } catch (error) {
      logger.error(`âŒ MCP ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨: ${error.message}`, error);

      // ë¶€ë¶„ ì„±ê³µ ê²°ê³¼ë¼ë„ ë°˜í™˜
      return {
        workflow: workflow.id,
        steps: executionContext.steps,
        status: 'partial_failure',
        error: error.message,
        duration: Date.now() - executionContext.startTime
      };
    }
  }

  // ðŸ”§ ì˜ë„ë³„ MCP ë„êµ¬ ì‹¤í–‰
  async executeMCPToolsForIntent(intent, serverId, sessionId) {
    const results = [];
    logger.info(`ðŸŽ¯ ì˜ë„ë³„ MCP ë„êµ¬ ì‹¤í–‰: ${intent.intent}`);

    try {
      switch (intent.intent) {
        case 'monitor_servers':
        case 'monitor_and_restart':
          return await this.executeServerMonitoringTools(intent, serverId, sessionId);
          
        case 'restart_service':
          return await this.executeServiceRestartTools(intent, serverId, sessionId);
          
        case 'backup_data':
          return await this.executeBackupTools(intent, serverId, sessionId);
          
        default:
          // ê¸°ë³¸ì ìœ¼ë¡œ ì„œë²„ ìƒíƒœ í™•ì¸
          return await this.executeDefaultServerCheck(intent, serverId, sessionId);
      }
    } catch (error) {
      logger.error(`âŒ ì˜ë„ë³„ MCP ë„êµ¬ ì‹¤í–‰ ì‹¤íŒ¨:`, error);
      results.push({
        type: 'error',
        intent: intent.intent,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  isMcpRelatedError(error) {
    const errorMessage = error.message || error.toString();
    return errorMessage.includes('UUID') || 
           errorMessage.includes('uuid') || 
           errorMessage.includes('MCP') || 
           errorMessage.includes('default-mcp-server');
  }

  // ðŸ”§ ì„œë²„ ëª¨ë‹ˆí„°ë§ ë„êµ¬ ì‹¤í–‰
  async executeServerMonitoringTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`ðŸ–¥ï¸ ì„œë²„ ëª¨ë‹ˆí„°ë§ ë„êµ¬ ì‹¤í–‰ ì‹œìž‘`);

    try {
      // 1. ë“±ë¡ëœ ë””ë°”ì´ìŠ¤ ëª©ë¡ ì¡°íšŒ
      const devices = await this.deviceClient.getDevices({ status: 'active' });
      logger.info(`ðŸ“‹ í™œì„± ë””ë°”ì´ìŠ¤: ${devices.items?.length || 0}ê°œ`);

      if (!devices.items || devices.items.length === 0) {
        results.push({
          type: 'info',
          message: 'ëª¨ë‹ˆí„°ë§í•  í™œì„± ë””ë°”ì´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤',
          timestamp: new Date().toISOString()
        });
        return results;
      }

      // 2. ì‹œìŠ¤í…œ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸ (ë¡œì»¬ ì‹œìŠ¤í…œ)
      try {
        logger.info(`ðŸ” ë¡œì»¬ ì‹œìŠ¤í…œ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸`);
        
        const processResult = await this.mcpClient.executeTool(
          serverId,
          'list_processes',
          {},
          false // ë™ê¸° ì‹¤í–‰
        );

        results.push({
          type: 'system_status',
          target: 'local_system',
          status: 'checked',
          processCount: this.parseProcessCount(processResult),
          timestamp: new Date().toISOString(),
          details: this.formatProcessResult(processResult)
        });

      } catch (processError) {
        logger.warn(`âš ï¸ ë¡œì»¬ ì‹œìŠ¤í…œ í”„ë¡œì„¸ìŠ¤ í™•ì¸ ì‹¤íŒ¨:`, processError);
        
        results.push({
          type: 'system_error',
          target: 'local_system',
          error: processError.message,
          timestamp: new Date().toISOString()
        });
      }

      // 3. Docker ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
      try {
        logger.info(`ðŸ³ Docker ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸`);
        
        const dockerResult = await this.mcpClient.executeTool(
          serverId,
          'start_process',
          {
            command: 'docker ps --format "table {{.Names}}\\t{{.Status}}" | grep automation',
            timeout_ms: 10000
          },
          false
        );

        results.push({
          type: 'docker_status',
          target: 'automation_containers',
          status: 'checked',
          timestamp: new Date().toISOString(),
          details: this.formatDockerResult(dockerResult)
        });

      } catch (dockerError) {
        logger.warn(`âš ï¸ Docker ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:`, dockerError);
        
        results.push({
          type: 'docker_error',
          target: 'automation_containers',
          error: dockerError.message,
          timestamp: new Date().toISOString()
        });
      }

      // 4. ë“±ë¡ëœ ë””ë°”ì´ìŠ¤ ì •ë³´ í¬í•¨
      for (const device of devices.items.slice(0, 3)) { // ìµœëŒ€ 3ê°œ ë””ë°”ì´ìŠ¤
        results.push({
          type: 'device_info',
          deviceId: device.id,
          deviceName: device.name,
          host: device.connectionInfo?.host || 'unknown',
          status: device.status,
          type: device.type,
          timestamp: new Date().toISOString()
        });
      }

      logger.info(`âœ… ì„œë²„ ëª¨ë‹ˆí„°ë§ ì™„ë£Œ: ${results.length}ê°œ ê²°ê³¼`);
      return results;

    } catch (error) {
      logger.error(`âŒ ì„œë²„ ëª¨ë‹ˆí„°ë§ ë„êµ¬ ì‹¤í–‰ ì‹¤íŒ¨:`, error);
      results.push({
        type: 'monitoring_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // ðŸ”§ ê¸°ë³¸ ì„œë²„ í™•ì¸
  async executeDefaultServerCheck(intent, serverId, sessionId) {
    logger.info(`ðŸ” ê¸°ë³¸ ì„œë²„ ìƒíƒœ í™•ì¸ ì‹¤í–‰`);
    return await this.executeServerMonitoringTools(intent, serverId, sessionId);
  }

  // ðŸ”§ ì„œë¹„ìŠ¤ ìž¬ì‹œìž‘ ë„êµ¬ ì‹¤í–‰ 
  async executeServiceRestartTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`ðŸ”„ ì„œë¹„ìŠ¤ ìž¬ì‹œìž‘ ë„êµ¬ ì‹¤í–‰ ì‹œìž‘`);

    try {
      // Docker ì»¨í…Œì´ë„ˆ ìž¬ì‹œìž‘ ì‹œë®¬ë ˆì´ì…˜
      const serviceName = intent.entities?.service || 'automation-workflow-engine';
      
      results.push({
        type: 'service_restart_simulated',
        service: serviceName,
        message: `${serviceName} ì„œë¹„ìŠ¤ ìž¬ì‹œìž‘ì´ ì‹œë®¬ë ˆì´ì…˜ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” docker restart ëª…ë ¹ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.`,
        timestamp: new Date().toISOString()
      });

      logger.info(`âœ… ì„œë¹„ìŠ¤ ìž¬ì‹œìž‘ ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ`);
      return results;

    } catch (error) {
      logger.error(`âŒ ì„œë¹„ìŠ¤ ìž¬ì‹œìž‘ ë„êµ¬ ì‹¤í–‰ ì‹¤íŒ¨:`, error);
      results.push({
        type: 'restart_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // ðŸ”§ ë°±ì—… ë„êµ¬ ì‹¤í–‰
  async executeBackupTools(intent, serverId, sessionId) {
    const results = [];
    logger.info(`ðŸ’¾ ë°±ì—… ë„êµ¬ ì‹¤í–‰ ì‹œìž‘`);

    try {
      // ë°±ì—… ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì‹œë®¬ë ˆì´ì…˜
      results.push({
        type: 'backup_simulated',
        message: 'ë°ì´í„° ë°±ì—…ì´ ì‹œë®¬ë ˆì´ì…˜ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ë°±ì—… ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.',
        timestamp: new Date().toISOString()
      });

      logger.info(`âœ… ë°±ì—… ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ`);
      return results;

    } catch (error) {
      logger.error(`âŒ ë°±ì—… ë„êµ¬ ì‹¤í–‰ ì‹¤íŒ¨:`, error);
      results.push({
        type: 'backup_error',
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return results;
    }
  }

  // ðŸ”§ í—¬í¼: í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ íŒŒì‹±
  parseProcessCount(processResult) {
    try {
      if (processResult && processResult.data && typeof processResult.data === 'string') {
        const lines = processResult.data.split('\n').filter(line => line.trim());
        return Math.max(0, lines.length - 1); // í—¤ë” ì œì™¸
      }
      return 0;
    } catch (error) {
      logger.warn('í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ íŒŒì‹± ì˜¤ë¥˜:', error);
      return 0;
    }
  }

  // ðŸ”§ í—¬í¼: í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ í¬ë§·íŒ…
  formatProcessResult(processResult) {
    try {
      if (processResult && processResult.data) {
        const lines = processResult.data.split('\n').slice(0, 5); // ìƒìœ„ 5ê°œë§Œ
        return lines.join('\n');
      }
      return 'No process data available';
    } catch (error) {
      logger.warn('í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ í¬ë§·íŒ… ì˜¤ë¥˜:', error);
      return 'Process data formatting error';
    }
  }

  // ðŸ”§ í—¬í¼: Docker ê²°ê³¼ í¬ë§·íŒ…
  formatDockerResult(dockerResult) {
    try {
      if (dockerResult && dockerResult.data) {
        return dockerResult.data.substring(0, 500); // ìµœëŒ€ 500ìž
      }
      return 'No docker data available';
    } catch (error) {
      logger.warn('Docker ê²°ê³¼ í¬ë§·íŒ… ì˜¤ë¥˜:', error);
      return 'Docker data formatting error';
    }
  }

  async createMcpErrorResponse(sessionId, message, error) {
    logger.warn(`ðŸ”„ MCP ì—ëŸ¬ í´ë°± ì‘ë‹µ ìƒì„±: ${error.message}`);
    
    const isUuidError = error.message.includes('UUID') || error.message.includes('uuid');
    
    let response;
    if (isUuidError) {
      response = 'ì£„ì†¡í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘ìž…ë‹ˆë‹¤. ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\n\ní˜„ìž¬ ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ëŠ¥:\nâ€¢ ì¼ë°˜ì ì¸ ì§ˆë¬¸ê³¼ ë‹µë³€\nâ€¢ ê°„ë‹¨í•œ ê³„ì‚°\nâ€¢ ì‹œìŠ¤í…œ ë„ì›€ë§';
    } else {
      response = 'ì¼ì‹œì ìœ¼ë¡œ ì¸í”„ë¼ ê´€ë¦¬ ê¸°ëŠ¥ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìžì—ê²Œ ë¬¸ì˜í•˜ê±°ë‚˜ ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
    }

    return {
      executionId: `mcp_error_${uuidv4()}`,
      workflowId: null,
      status: 'failed',
      response: response,
      type: 'error_response',
      error: {
        type: 'mcp_error',
        message: error.message,
        recoverable: true
      },
      duration: 0
    };
  }

  async createErrorResponse(sessionId, message, error) {
    logger.error(`ðŸ’¥ ìµœì¢… ì—ëŸ¬ ì‘ë‹µ ìƒì„±: ${error.message}`);
    
    return {
      executionId: `final_error_${uuidv4()}`,
      workflowId: null,
      status: 'failed',
      response: 'ì‹œìŠ¤í…œì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      type: 'system_error',
      error: {
        type: 'system_error',
        message: error.message,
        recoverable: false
      },
      duration: 0
    };
  }

  async generateErrorResponse(message, error) {
    try {
      return await this.llmClient.generateErrorResponse(message, error);
    } catch (llmError) {
      logger.error(`âŒ LLM ì—ëŸ¬ ì‘ë‹µ ìƒì„± ì‹¤íŒ¨:`, llmError);
      return `ì£„ì†¡í•©ë‹ˆë‹¤. "${message}" ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`;
    }
  }

  // ì›Œí¬í”Œë¡œìš° ì„ íƒ (ê°„ì†Œí™”ëœ ë²„ì „)
  async selectWorkflow(intent) {
    try {
      return {
        id: `fallback_${Date.now()}`,
        name: 'Fallback Workflow',
        description: 'í´ë°± ì›Œí¬í”Œë¡œìš°'
      };
    } catch (error) {
      logger.error(`âŒ ì›Œí¬í”Œë¡œìš° ì„ íƒ ì‹¤íŒ¨:`, error);
      return null;
    }
  }

  // n8n ê²°ê³¼ ì²˜ë¦¬
  processN8nResults(n8nResult) {
    logger.info(`ðŸ“Š n8n ê²°ê³¼ ì²˜ë¦¬ ì‹œìž‘: ${n8nResult.id}`);
    
    try {
      const runData = n8nResult.data?.resultData?.runData || {};
      const results = [];
      
      Object.entries(runData).forEach(([nodeName, nodeData], index) => {
        const nodeResult = {
          stepIndex: index,
          stepName: nodeName,
          success: nodeData && nodeData.length > 0,
          data: nodeData || null,
          duration: 0
        };
        
        results.push(nodeResult);
      });
      
      const summary = {
        totalNodes: results.length,
        successfulNodes: results.filter(r => r.success).length,
        failedNodes: results.filter(r => !r.success).length,
        overallSuccess: results.length > 0 && results.some(r => r.success)
      };
      
      return {
        steps: results,
        summary: summary,
        n8nExecutionId: n8nResult.id
      };
      
    } catch (processingError) {
      logger.error(`âŒ n8n ê²°ê³¼ ì²˜ë¦¬ ì‹¤íŒ¨:`, processingError);
      
      return {
        steps: [{
          stepIndex: 0,
          stepName: 'n8n-execution',
          success: false,
          error: processingError.message,
          duration: 0
        }],
        summary: {
          totalNodes: 1,
          successfulNodes: 0,
          failedNodes: 1,
          overallSuccess: false
        },
        n8nExecutionId: n8nResult.id
      };
    }
  }

  // ì‹¤í–‰ ê²°ê³¼ ì €ìž¥
  async saveExecutionToStorage(executionData) {
    try {
      logger.info(`ðŸ’¾ ì‹¤í–‰ ê²°ê³¼ ì €ìž¥: ${executionData.executionId}`);
      
      const executionRecord = {
        id: executionData.executionId,
        workflow_id: executionData.workflowId,
        n8n_execution_id: executionData.n8nExecutionId,
        session_id: executionData.sessionId,
        status: executionData.status,
        intent: JSON.stringify(executionData.intent),
        template_name: executionData.templateName,
        started_at: executionData.startedAt,
        completed_at: executionData.completedAt,
        response_text: executionData.response,
        duration_ms: executionData.duration,
        created_at: new Date()
      };
      
      await workflowService.saveExecution(executionRecord);
      
      logger.info(`âœ… ì‹¤í–‰ ê²°ê³¼ ì €ìž¥ ì™„ë£Œ: ${executionData.executionId}`);
      
    } catch (storageError) {
      logger.error(`âŒ ì‹¤í–‰ ê²°ê³¼ ì €ìž¥ ì‹¤íŒ¨: ${executionData.executionId}`, storageError);
    }
  }

  async saveExecutionRecord(executionData) {
    try {
      await workflowService.createExecution(executionData);
      await redisService.addSessionExecution(
        executionData.sessionId, 
        executionData.executionId
      );
    } catch (error) {
      logger.error(`âŒ ì‹¤í–‰ ê¸°ë¡ ì €ìž¥ ì‹¤íŒ¨:`, error);
    }
  }

  // ðŸš€ TASK-WF-004: ê³ ê¸‰ ì›Œí¬í”Œë¡œìš° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ë©”ì„œë“œë“¤

  /**
   * ì‹¤í–‰ ê³„íš ìƒì„±
   */
  async createExecutionPlan(intent, workflow) {
    logger.info(`ðŸ“‹ ì‹¤í–‰ ê³„íš ìƒì„±: ${workflow.name}`);
    
    const plan = createExecutionPlan(intent, workflow);
    
    // ì˜ë„ì—ì„œ ì¶”ì¶œëœ ì—”í‹°í‹° ì •ë³´ ì¶”ê°€
    plan.context = {
      intent: intent.intent,
      entities: intent.entities || {},
      originalMessage: intent.original_message
    };
    
    return plan;
  }

  /**
   * ì‹¤í–‰ ìš”êµ¬ì‚¬í•­ ê²€ì¦
   */
  async validateExecutionRequirements(executionPlan) {
    logger.info(`ðŸ” ì‹¤í–‰ ìš”êµ¬ì‚¬í•­ ê²€ì¦ ì¤‘...`);

    // 1. MCP ì„œë²„ ê°€ìš©ì„± í™•ì¸
    const mcpServers = await this.mcpClient.getServers();
    if (!mcpServers.items || mcpServers.items.length === 0) {
      throw new Error('ì‹¤í–‰ì— í•„ìš”í•œ MCP ì„œë²„ê°€ ì—†ìŠµë‹ˆë‹¤');
    }

    // 2. desktop-commander ì„œë²„ í™•ì¸
    const desktopCommander = mcpServers.items.find(server => 
      server.name === 'desktop-commander' && server.status === 'active'
    );
    
    if (!desktopCommander) {
      throw new Error('desktop-commander MCP ì„œë²„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }

    logger.info(`âœ… ì‹¤í–‰ ìš”êµ¬ì‚¬í•­ ê²€ì¦ ì™„ë£Œ`);
  }

  /**
   * ë³‘ë ¬ ë‹¨ê³„ ì‹¤í–‰
   */
  async executeStepsInParallel(steps, context) {
    logger.info(`âš¡ ë³‘ë ¬ ì‹¤í–‰ ì‹œìž‘: ${steps.length}ê°œ ë‹¨ê³„`);

    const promises = steps.map(async (step, index) => {
      const stepContext = { ...context, stepIndex: index, step };

      try {
        // ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™© ë³´ê³ 
        await this.sendStepProgress(context.sessionId, 'started', step);

        const result = await this.executeWorkflowStep(step, stepContext);

        await this.sendStepProgress(context.sessionId, 'completed', step, result);

        return result;
      } catch (stepError) {
        logger.error(`âŒ ë³‘ë ¬ ë‹¨ê³„ ${index} ì‹¤í–‰ ì‹¤íŒ¨:`, stepError);

        await this.sendStepProgress(context.sessionId, 'failed', step, null, stepError);

        return {
          stepIndex: index,
          step,
          success: false,
          error: stepError.message,
          duration: 0
        };
      }
    });

    const results = await Promise.allSettled(promises);

    return results.map((result, index) => ({
      stepIndex: index,
      success: result.status === 'fulfilled',
      data: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason.message : null
    }));
  }

  /**
   * ìˆœì°¨ ë‹¨ê³„ ì‹¤í–‰
   */
  async executeStepsSequentially(steps, context) {
    logger.info(`ðŸ”„ ìˆœì°¨ ì‹¤í–‰ ì‹œìž‘: ${steps.length}ê°œ ë‹¨ê³„`);

    const results = [];

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      const stepContext = { ...context, stepIndex: i, step };

      try {
        await this.sendStepProgress(context.sessionId, 'started', step);

        const result = await this.executeWorkflowStep(step, stepContext);

        await this.sendStepProgress(context.sessionId, 'completed', step, result);

        results.push({
          stepIndex: i,
          step,
          success: true,
          data: result,
          duration: result.duration || 0
        });

        // ì´ì „ ë‹¨ê³„ ê²°ê³¼ë¥¼ ë‹¤ìŒ ë‹¨ê³„ ì»¨í…ìŠ¤íŠ¸ì— ì¶”ê°€
        stepContext.previousResults = results;

      } catch (stepError) {
        logger.error(`âŒ ìˆœì°¨ ë‹¨ê³„ ${i} ì‹¤í–‰ ì‹¤íŒ¨:`, stepError);

        await this.sendStepProgress(context.sessionId, 'failed', step, null, stepError);

        // ì‹¤íŒ¨ ì²˜ë¦¬ ì „ëžµ ê²°ì •
        const recoveryStrategy = await this.determineRecoveryStrategy(step, stepError, stepContext);

        if (recoveryStrategy === 'abort') {
          logger.warn(`ðŸ›‘ ìˆœì°¨ ì‹¤í–‰ ì¤‘ë‹¨: ${step.name}`);
          break;
        } else if (recoveryStrategy === 'skip') {
          logger.warn(`â­ï¸ ë‹¨ê³„ ê±´ë„ˆë›°ê¸°: ${step.name}`);
          results.push({
            stepIndex: i,
            step,
            success: false,
            error: stepError.message,
            skipped: true
          });
        } else if (recoveryStrategy === 'retry') {
          // ìž¬ì‹œë„ ë¡œì§ (ê°„ë‹¨í•œ ë²„ì „)
          i--; // í˜„ìž¬ ë‹¨ê³„ ìž¬ì‹œë„
        }
      }
    }

    return results;
  }
}

module.exports = new ChatOrchestrator();
